A. Abelian Groups

B. Coins

C. Greatest Greatest Common Divisor
给定n（1<=n<=100000）小于100000的正整数，求任意一对最大公约数中的最大的一个。
约数 对于每个正整数a，可以用根号a的时间复杂度求得a的所有约数ki，并把下标为ki的数组加1，最后从大到小遍历这些约数，如果这些约数的个数超过1的话，那么第一次遍历的这个最大的约数，即为所有最大公约数中的最大值了。

D. Circular Island

E. Octahedron And Dominoes

F. Digits Permutation
给定一个小于10^17的数字，要求你从新排列这些数字，使得到的新的数字能被17整除。
状态压缩的DP f[i][j][k]表示现在已经确定了前i个数字，这17个数字分别是那i个被二进制压缩在j中，且他们的对17取余为k，如果这个状态存在就标记为true，枚举第i为的字符为s[l]，
				f[i][j][ (k+s[l]-‘0’）%17] |= f[i-1][j-(1<<l)][k]


G. Running City

H. Square Palindrome

I. Prefixes and suffixes

J. Subsequences Of Substrings

K. Treediff


